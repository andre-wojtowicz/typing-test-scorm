const paragraphs = [
"Running ls -la /var/log/nginx/ often reveals hidden rotated logs and unexpected permission issues. Editing configuration files like /etc/nginx/nginx.conf requires careful attention to spacing and semicolons because a single missing character can stop the entire service. The variable $LOG_PATH should normally point to /var/log/app/, but many users misconfigure it to /tmp/app/ which gets wiped unexpectedly. Using grep -R error ./src | wc -l helps count issues quickly but combining it with sed -E s/[0-9]+/X/g allows masking numbers. Administrators often find that sorting files with sort -t: -k3 improves readability when analyzing metrics. Remember that escaping sequences like \$HOME or \$PWD is necessary inside scripts that rely on literal variable names.",
  
  "The command for i in {1..10}; do echo $i; done is essential for beginners to understand loops, but more advanced ranges like for n in {0001..0500} challenge typing accuracy. A typical executable path such as /usr/local/bin/script.sh may fail if chmod +x is forgotten and scripts using /bin/sh may behave differently from those using /bin/bash. Logical operators like && to chain commands or || to trigger fallbacks are crucial when writing setup routines. Many people forget to escape special characters in echo \"Path: \$PATH\" which leads to unintended expansion. Combining sleep 0.5 with repeated loops helps simulate background tasks, while using touch ./out/log_$(date +%s).txt generates timestamp-based files.",
  
  "Creating compressed archives with tar -czvf backup_$(date +%Y-%m-%d).tar.gz ./project/ is common, but adding --exclude node_modules or --exclude *.tmp helps reduce archive size. Users should never run destructive commands like rm -rf / because even testing such strings in documentation requires caution. Variables such as $USER, $SHELL, $RANDOM or custom exports in ~/.bash_profile can drastically affect script behavior. Redirecting errors with 2>/dev/null keeps logs clean and combining >&1 merges streams. Checking disk usage with df -h and monitoring memory with free -m are core administrative skills. A well-written script often validates inputs to avoid catastrophic operations.",
  
  "Bash arrays such as arr=(alpha beta gamma delta epsilon) look simple until expansions like ${arr[@]:2:3} appear in longer scripts. Restarting services using sudo systemctl restart app.service after deployments is routine. Multi-flag commands like curl -X POST -H Content-Type:application/json -d '{\"id\":123}' http://localhost:8080/api/test push users to type carefully. Conditions using [[ -f \"$FILE\" && -s \"$FILE\" ]] determine whether a file exists and is not empty. Many engineers forget to quote arguments containing spaces which results in unpredictable globbing. Complex scripts often include loops parsing lines via while IFS=: read a b c; do echo \"$a\"; done < /etc/passwd.",
  
  "Using find /etc -type f -name *.conf helps list configuration files, while combining it with xargs grep timeout improves diagnostics. Common patterns like ps aux | grep python | grep -v grep are error-prone and should ideally be replaced with pgrep -f python. Running mkdir -p ./build/output/temp ensures directories exist and piping logs into tail -n 50 logfile.log aids troubleshooting. Sorting entries with sort -h /var/data/sizes.txt and formatting numbers with printf \"%05d\" enhance clarity. The command wc -l ./records/list.txt quickly reveals line counts. Administrators often chain du -sh ./* with grep -v cache for clearer reports.",
  
  "Pipelines such as cat data.txt | awk '{print $1,$3}' | sort -n are useful but repeatedly typing patterns with quotes is difficult. Quoting rules matter because single quotes prevent expansion while double quotes allow variable evaluation. Connecting to remote hosts via ssh user@192.168.0.10 may require keys stored in ~/.ssh/id_rsa and file permissions set with chmod 600. Operators like > to overwrite and >> to append are essential for logging. Regex expressions passed to grep -E often require escaping characters like ^, $, + or {}. Moving files with mv *.log /var/archive/ is common, as is cleaning temp directories using rm -f /tmp/session_*.pid.",
  
  "Loops like while true; do echo tick; sleep 1; done require interrupting with Ctrl+C. Updating environment variables through export PATH=$PATH:/opt/tools/ is common but forgetting to persist them in ~/.bashrc causes confusion. The script header #!/bin/bash must be first to ensure correct shell execution. Test conditions such as [ \"$x\" -eq 1 ] versus [ \"$x\" -eq 1] show how missing spaces cause cryptic errors. Many scripts generate temp files via dir=/tmp/app_$(uuidgen) and mkdir -p \"$dir\" before use. Administrators also rely on basename and dirname to manipulate file paths dynamically.",
  
  "Permissions like chmod 644 file.txt set read-write for owners only, while chmod 755 script.sh makes it executable. Combined conditions like if [[ -f \"$FILE\" && -s \"$FILE\" ]]; then echo OK; fi are extremely common. Quoting file paths such as /home/user/My Documents/notes.txt avoids globbing issues. Parsing logs with awk '{print $1,$5}' /var/log/syslog can reveal patterns quickly. Creating backups via cp -r ./config ./backup/config_$(date +%H%M%S) ensures historical tracking. Developers frequently misplace parentheses in variable expansions like ${name%%_*} when trimming suffixes.",
  
  "Running bash -x script.sh enables debugging and reveals expansion order. Temporary directories like /tmp/run_$(uuidgen)/ are helpful when processing batches. Replacing outdated backticks with modern command substitution $(command) improves readability. Typical log entries include INFO task completed at $(date +%T) and timestamps help correlate events. Administrators often rely on sed -E s/[ ]+/ /g to normalize whitespace or cut -d: -f1 /etc/passwd to extract usernames. Monitoring jobs with jobs -l or backgrounding tasks using & is essential in daily workflows.",
  
  "Using du -sh ./* | sort -h displays directory sizes in human-readable form. Cronjobs such as 0 */6 * * * /usr/bin/bash /opt/backup.sh run at fixed intervals and require precise formatting. Escaping metacharacters in grep -E ^[a-zA-Z0-9_]{3,}$ is tricky but necessary. Formatting numbers with printf \"%04d\n\" 7 produces 0007 which helps align output. Syncing data with rsync -av --delete ./src/ ./dst/ avoids stale files. Many scripts scan network status using ping -c 4 8.8.8.8 or check open ports with netstat -tulnp. Cleaning caches via rm -rf ~/.cache/app/* is common yet risky if typed incorrectly."
];
